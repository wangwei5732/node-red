/* eslint-disable no-await-in-loop */
const when = require('when');
const Promise = when.promise;
const sql = require('mysql');
const mysql2 = require('mysql2/promise');
const Sequelize = require("sequelize");

const path = require('path');
const fs = require('fs');
// 获取当前脚本的所在目录
const scriptDirectory = __dirname;
// 构建相对路径
const sqlFilePath = path.join(scriptDirectory, 'node_red.sql');
// 读取.sql文件内容并执行
const sqls = fs.readFileSync(sqlFilePath, 'utf8');

const MysqlHandler = class MysqlHandler {
  constructor(sqlConfig) {
    this.sqlConfig = sqlConfig;
    this.sqlConfig.multipleStatements = true;
  }

  async connect() {
    // 连接数据库
    let connection2 = await mysql2.createConnection({
        host: '114.115.207.1',
        port: '13306',
        user: 'root',
        password: 'Hollysys4321!',
      });
    // 初始化数据库
    await connection2.query(`    CREATE DATABASE IF NOT EXISTS node_red;`);
    await connection2.query(`USE node_red; `);
    await connection2.query(`CREATE TABLE IF NOT EXISTS node_red_credentials (CredentialID INT (11) NOT NULL AUTO_INCREMENT,JsonData LONGTEXT DEFAULT NULL,PRIMARY KEY (CredentialID)) ENGINE=INNODB DEFAULT CHARSET=utf8;    `);
    await connection2.query(`CREATE TABLE IF NOT EXISTS node_red_library (LibraryID INT (11) NOT NULL AUTO_INCREMENT,Type VARCHAR (10) DEFAULT NULL,Path LONGTEXT DEFAULT NULL,Meta LONGTEXT DEFAULT NULL,JsonData LONGTEXT DEFAULT NULL,PRIMARY KEY (LibraryID)) ENGINE=INNODB DEFAULT CHARSET=utf8;`);
    await connection2.query(`CREATE TABLE IF NOT EXISTS node_red_sessions (SessionID INT (11) NOT NULL AUTO_INCREMENT,JsonData LONGTEXT DEFAULT NULL,PRIMARY KEY (SessionID)) ENGINE=INNODB DEFAULT CHARSET=utf8;`);
    await connection2.query(`CREATE TABLE IF NOT EXISTS node_red_settings (SettingID INT (11) NOT NULL AUTO_INCREMENT,JsonData LONGTEXT DEFAULT NULL,PRIMARY KEY (SettingID)) ENGINE=INNODB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8; `);
    await connection2.query(`SET FOREIGN_KEY_CHECKS=1;`);

    connection2.close()

    return Promise((resolve, reject) => {
      try {
        this.pool = sql.createPool(this.sqlConfig);
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  }

  findAll(tableName) {
    return Promise(async (resolve, reject) => {
      this.pool.query(`SELECT JsonData FROM ${tableName}`, (err, results) => {
        if (err) {
          reject(err);
        } else if (results[0]) {
          resolve(JSON.parse(results[0].JsonData));
        } else {
          resolve([]);
        }
      });
    });
  }

  findOne(tableName) {
    return Promise(async (resolve, reject) => {
      this.pool.query(`SELECT JsonData FROM ${tableName}`, (err, results) => {
        if (err) {
          reject(err);
        } else if (results[0]) {
          resolve(JSON.parse(results[0].JsonData));
        } else {
          resolve({});
        }
      });
    });
  }
  saveAll(tableName, objects) {
    return Promise(async (resolve, reject) => {
      this.pool.query(
        `DELETE FROM ${tableName};INSERT INTO ${tableName} (JsonData) VALUES (?)`,
        [JSON.stringify(objects)],
        err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  findLibraryEntry(tableName, type, path) {
    return Promise(async (resolve, reject) => {
      this.pool.query(
        `SELECT * FROM ${tableName} WHERE Type = ?`,
        [type],
        (err, results) => {
          if (err) {
            reject(err);
          } else {
            const returnStructure = [];
            for (let i = 0; i < results.length; i += 1) {
              const entry = result[i];

              if (entry.Path.indexOf('/') === -1 && path === '') {
                returnStructure.push({
                  fn: entry.Path,
                  meta: entry.Meta,
                  body: entry.JsonData
                });
              } else if (path === '') {
                returnStructure.push(entry.Path.split('/')[0]);
              } else if (entry.Path.indexOf(path) !== -1) {
                const subpath = entry.Path.split(path)[1];
                if (subpath.indexOf('/') === -1) {
                  returnStructure.push({
                    fn: subpath,
                    meta: entry.Meta,
                    body: entry.JsonData
                  });
                } else {
                  for (let x = 0; x < subpath.split('/').length - 1; x += 1) {
                    returnStructure.push(subpath.split('/')[x]);
                  }
                }
              }
            }
            resolve(returnStructure);
          }
        }
      );
    });
  }

  saveLibraryEntry(tableName, type, path, meta, body) {
    return Promise((resolve, reject) => {
      this.pool.query(
        `DELETE FROM ${tableName} WHERE Type = ? AND Path = ?;INSERT INTO ${tableName} (Type, Path, Meta, JsonData) VALUES (?, ?, ?, ?)`,
        [type, path, type, path, JSON.stringify(meta), body],
        err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }
};

module.exports = MysqlHandler;
